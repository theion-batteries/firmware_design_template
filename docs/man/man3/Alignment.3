.TH "Alignment" 3 "Tue May 24 2022" "Version 0.2" "Firmware Design Template" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Alignment
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Alignment\&.hpp>\fP
.PP
Inherited by \fBFirmwareUnit\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBAlignment\fP (\fBNema8\fP *\fBMotor_x\fP, \fBNema8\fP *\fBMotor_y\fP, \fBNema8\fP *\fBMotor_z\fP, \fBDistanceSensor\fP *\fBDistanceM_x\fP, \fBDistanceSensor\fP *\fBDistanceM_y\fP, \fBDistanceSensor\fP *\fBDistanceM_z\fP, \fBendSwitch\fP *\fBendSwitch_x\fP, \fBendSwitch\fP *\fBendSwitch_y\fP, \fBendSwitch\fP *\fBendSwitch_z\fP)"
.br
.ti -1c
.RI "\fBAlignment\fP (\fBNema8\fP *\fBMotor_x\fP, \fBNema8\fP *\fBMotor_y\fP, \fBNema8\fP *\fBMotor_z\fP, \fBDistanceSensor\fP *\fBDistanceM_x\fP, \fBDistanceSensor\fP *\fBDistanceM_y\fP, \fBDistanceSensor\fP *\fBDistanceM_z\fP, \fBendSwitch\fP *\fBendSwitch_x\fP, \fBendSwitch\fP *\fBendSwitch_y\fP, \fBendSwitch\fP *\fBendSwitch_z\fP, \fBendSwitch\fP *\fBendSwitch_stop\fP, \fBlightBarrier\fP *\fBlightBarrier_x\fP, \fBlightBarrier\fP *\fBlightBarrier_y\fP, \fBlightBarrier\fP *\fBlightBarrier_z\fP)"
.br
.ti -1c
.RI "\fBAlignment\fP (\fBNema8\fP *\fBMotor_x\fP, \fBNema8\fP *\fBMotor_y\fP, \fBNema8\fP *\fBMotor_z\fP, \fBNema8\fP *\fBMotor_PrintHead\fP, \fBDistanceSensor\fP *\fBDistanceM_x\fP, \fBDistanceSensor\fP *\fBDistanceM_y\fP, \fBDistanceSensor\fP *\fBDistanceM_z\fP, \fBendSwitch\fP *\fBendSwitch_x\fP, \fBendSwitch\fP *\fBendSwitch_y\fP, \fBendSwitch\fP *\fBendSwitch_z\fP, \fBendSwitch\fP *\fBendSwitch_stop\fP, \fBlightBarrier\fP *\fBlightBarrier_x\fP, \fBlightBarrier\fP *\fBlightBarrier_y\fP, \fBlightBarrier\fP *\fBlightBarrier_z\fP)"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveDistanceMSafe\fP (\fBNema8\fP *Mref, int direction, float distance)"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveDistanceXloop\fP (int direction, float distance)"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveDistanceYloop\fP (int direction, float distance)"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveDistanceZloop\fP (int direction, float distance)"
.br
.ti -1c
.RI "\fBretVal\fP \fBRotateAnglePHloop\fP (\fBNema8\fP *Mref, int direction, float angle)"
.br
.ti -1c
.RI "bool \fBisStopButtonPressed\fP ()"
.br
.ti -1c
.RI "void \fBinitFirmwareUnit\fP ()"
.br
.ti -1c
.RI "\fBretVal\fP \fBStepOnceX\fP (int direction)"
.br
.ti -1c
.RI "\fBretVal\fP \fBStepOnceY\fP (int direction)"
.br
.ti -1c
.RI "\fBretVal\fP \fBStepOnceZ\fP (int direction)"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveDistanceX\fP (int direction, float distance)"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveDistanceY\fP (int direction, float distance)"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveDistanceZ\fP (int direction, float distance)"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveDistanceAll\fP (int direction, float distance)"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveAngleX\fP (int direction, float angle)"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveAngleY\fP (int direction, float angle)"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveAngleZ\fP (int direction, float angle)"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveAngleAll\fP (int direction, float angle)"
.br
.ti -1c
.RI "double \fBgetValueSensorX\fP ()"
.br
.ti -1c
.RI "double \fBgetValueSensorY\fP ()"
.br
.ti -1c
.RI "double \fBgetValueSensorZ\fP ()"
.br
.ti -1c
.RI "bool \fBgetReadingEndstopX\fP ()"
.br
.ti -1c
.RI "bool \fBgetReadingEndstopY\fP ()"
.br
.ti -1c
.RI "bool \fBgetReadingEndstopZ\fP ()"
.br
.ti -1c
.RI "bool \fBgetReadingLightBarrierX\fP ()"
.br
.ti -1c
.RI "bool \fBgetReadingLightBarrierY\fP ()"
.br
.ti -1c
.RI "bool \fBgetReadingLightBarrierZ\fP ()"
.br
.ti -1c
.RI "\fBretVal\fP \fBGoToReferenceDown\fP ()"
.br
.ti -1c
.RI "int \fBconvertDistanceToStepMicros\fP (float distance)"
.br
.ti -1c
.RI "int \fBconvertAngleToStep\fP (float angle)"
.br
.ti -1c
.RI "float \fBgetDistancePrintHeadToMl\fP ()"
.br
.ti -1c
.RI "float \fBgetDistancePrintHeadToMlX\fP ()"
.br
.ti -1c
.RI "float \fBgetDistancePrintHeadToMlY\fP ()"
.br
.ti -1c
.RI "float \fBgetDistancePrintHeadToMlZ\fP ()"
.br
.ti -1c
.RI "float \fBgetDistancePlatformToMlX\fP ()"
.br
.ti -1c
.RI "float \fBgetDistancePlatformToMlY\fP ()"
.br
.ti -1c
.RI "float \fBgetDistancePlatformToMlZ\fP ()"
.br
.ti -1c
.RI "float \fBgetDistancePlatformToMlXYZ\fP ()"
.br
.ti -1c
.RI "\fBretVal\fP \fBGoToReferenceUp\fP ()"
.br
.ti -1c
.RI "\fBretVal\fP \fBcalibratePrintHead\fP ()"
.br
.ti -1c
.RI "bool \fBcheckLimitUpX\fP ()"
.br
.ti -1c
.RI "bool \fBcheckLimitUpY\fP ()"
.br
.ti -1c
.RI "bool \fBcheckLimitUpZ\fP ()"
.br
.ti -1c
.RI "bool \fBcheckLimitUpXYZ\fP ()"
.br
.ti -1c
.RI "bool \fBcheckLimitDownX\fP ()"
.br
.ti -1c
.RI "bool \fBcheckLimitDownY\fP ()"
.br
.ti -1c
.RI "bool \fBcheckLimitDownZ\fP ()"
.br
.ti -1c
.RI "bool \fBcheckLimitDownXYZ\fP ()"
.br
.ti -1c
.RI "\fBretVal\fP \fBStepDownXMax\fP ()"
.br
.ti -1c
.RI "\fBretVal\fP \fBStepDownYMax\fP ()"
.br
.ti -1c
.RI "\fBretVal\fP \fBStepDownZMax\fP ()"
.br
.ti -1c
.RI "\fBretVal\fP \fBStepUpXMax\fP ()"
.br
.ti -1c
.RI "\fBretVal\fP \fBStepUpYMax\fP ()"
.br
.ti -1c
.RI "\fBretVal\fP \fBStepUpZMax\fP ()"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveDistanceXSafe\fP (int direction, float distance)"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveDistanceYSafe\fP (int direction, float distance)"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveDistanceZSafe\fP (int direction, float distance)"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveDistanceAllSafe\fP (int direction, float distance)"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveAngleXSafe\fP (int direction, float Angle)"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveAngleYSafe\fP (int direction, float Angle)"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveAngleZSafe\fP (int direction, float Angle)"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveAngleAllSafe\fP (int direction, float Angle)"
.br
.ti -1c
.RI "\fBretVal\fP \fBStepOncePH\fP (int direction)"
.br
.ti -1c
.RI "\fBretVal\fP \fBrotateFullRevPH\fP (int direction)"
.br
.ti -1c
.RI "\fBretVal\fP \fBrotateAnglePH\fP (int direction, float Angle)"
.br
.ti -1c
.RI "\fBretVal\fP \fBoscillateSys\fP (float desired_angle, int num_revolutions, bool default_sens=\fBclk\fP, bool reverse_sense=true)"
.br
.ti -1c
.RI "\fBretVal\fP \fBmovePhToRefX\fP ()"
.br
.ti -1c
.RI "\fBretVal\fP \fBinitSensors\fP ()"
.br
.ti -1c
.RI "void \fBincrementTotalStepCounted\fP ()"
.br
.ti -1c
.RI "void \fBresetStepCounter\fP ()"
.br
.ti -1c
.RI "float \fBgetCurrentPosX\fP ()"
.br
.ti -1c
.RI "float \fBgetCurrentPosY\fP ()"
.br
.ti -1c
.RI "float \fBgetCurrentPosZ\fP ()"
.br
.ti -1c
.RI "float \fBCheckBoundaryX\fP (float targetDistance, int direction)"
.br
.ti -1c
.RI "\fBretVal\fP \fBInitAlign\fP (bool enable=\fBon\fP)"
.br
.RI "setup stuff to initialise enable, direction and so on "
.ti -1c
.RI "\fBretVal\fP \fBEnableAll\fP (bool enable=\fBon\fP)"
.br
.ti -1c
.RI "\fBretVal\fP \fBDisableAll\fP (bool enable=\fBoff\fP)"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveHomeAll\fP ()"
.br
.RI "Move all motors home @algorithm: check if every motor endswitch is not pressed, then move \fBNema8\fP up\&. "
.ti -1c
.RI "\fBretVal\fP \fBAlignLoop\fP ()"
.br
.RI "This is the main function to keep track of alignment during process @algorithm: compare value of distance sensor for each motor with target and calibrate\&. "
.ti -1c
.RI "float \fBgetRemainingDistanceX\fP ()"
.br
.ti -1c
.RI "float \fBgetRemainingDistanceY\fP ()"
.br
.ti -1c
.RI "float \fBgetRemainingDistanceZ\fP ()"
.br
.RI "get the real distance based on mechanical construction in this setup "
.ti -1c
.RI "float \fBgetMinX\fP ()"
.br
.RI "get mesured values minus thickness of sensor: equal to 0 position "
.ti -1c
.RI "float \fBgetMinY\fP ()"
.br
.ti -1c
.RI "float \fBgetMinZ\fP ()"
.br
.ti -1c
.RI "float \fBgetMaxX\fP ()"
.br
.ti -1c
.RI "float \fBgetMaxY\fP ()"
.br
.ti -1c
.RI "float \fBgetMaxZ\fP ()"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveUp\fP (bool x, bool y, bool z, bool checkLimit)"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveDown\fP (bool x, bool y, bool z, bool checkLimit)"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveUpTo\fP (bool x, bool y, bool z, bool checkLimit, float distance)"
.br
.ti -1c
.RI "\fBretVal\fP \fBMoveDownTo\fP (bool x, bool y, bool z, bool checkLimit, float distance)"
.br
.ti -1c
.RI "\fBretVal\fP \fBsetTargetDistancePHToML\fP (float distance)"
.br
.RI "set new target distance to ML "
.ti -1c
.RI "\fBretVal\fP \fBsetTargetDistanceSensorToML\fP (float distance)"
.br
.ti -1c
.RI "int \fBConvertDistanceToStep\fP (float distance)"
.br
.RI "convert distance in mm or µm to step or microstep "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBNema8\fP * \fBMotor_x\fP"
.br
.ti -1c
.RI "\fBNema8\fP * \fBMotor_y\fP"
.br
.ti -1c
.RI "\fBNema8\fP * \fBMotor_z\fP"
.br
.ti -1c
.RI "\fBNema8\fP * \fBMotor_PrintHead\fP"
.br
.ti -1c
.RI "\fBendSwitch\fP * \fBendSwitch_x\fP"
.br
.ti -1c
.RI "\fBendSwitch\fP * \fBendSwitch_y\fP"
.br
.ti -1c
.RI "\fBendSwitch\fP * \fBendSwitch_z\fP"
.br
.ti -1c
.RI "\fBendSwitch\fP * \fBendSwitch_stop\fP"
.br
.ti -1c
.RI "\fBlightBarrier\fP * \fBlightBarrier_x\fP"
.br
.ti -1c
.RI "\fBlightBarrier\fP * \fBlightBarrier_y\fP"
.br
.ti -1c
.RI "\fBlightBarrier\fP * \fBlightBarrier_z\fP"
.br
.ti -1c
.RI "\fBDistanceSensor\fP * \fBDistanceM_x\fP"
.br
.ti -1c
.RI "\fBDistanceSensor\fP * \fBDistanceM_y\fP"
.br
.ti -1c
.RI "\fBDistanceSensor\fP * \fBDistanceM_z\fP"
.br
.ti -1c
.RI "const float \fBMinDistanceToML\fP = 10"
.br
.ti -1c
.RI "const float \fBMaxDistanceToMl\fP = 60"
.br
.ti -1c
.RI "float \fBTargetDistancePHToMl\fP =70"
.br
.ti -1c
.RI "float \fBTargetDistanceSensorToMl\fP =165"
.br
.ti -1c
.RI "int \fBNumOfCycles\fP =0"
.br
.ti -1c
.RI "bool \fBhomed\fP = false"
.br
.ti -1c
.RI "bool \fBaligned\fP = false"
.br
.ti -1c
.RI "bool \fBallDownMax\fP = false"
.br
.ti -1c
.RI "bool \fBxDownMax\fP = false"
.br
.ti -1c
.RI "bool \fByDownMax\fP = false"
.br
.ti -1c
.RI "bool \fBzDownMax\fP = false"
.br
.ti -1c
.RI "bool \fBallUpMax\fP = false"
.br
.ti -1c
.RI "bool \fBxUpMax\fP = false"
.br
.ti -1c
.RI "bool \fByUpMax\fP = false"
.br
.ti -1c
.RI "bool \fBzUpMax\fP = false"
.br
.ti -1c
.RI "bool \fBxUpDistanceArrived\fP = false"
.br
.ti -1c
.RI "bool \fByUpDistanceArrived\fP = false"
.br
.ti -1c
.RI "bool \fBzUpDistanceArrived\fP = false"
.br
.ti -1c
.RI "bool \fBallUpDistanceArrived\fP = false"
.br
.ti -1c
.RI "bool \fBxDownDistanceArrived\fP = false"
.br
.ti -1c
.RI "bool \fByDownDistanceArrived\fP = false"
.br
.ti -1c
.RI "bool \fBzDownDistanceArrived\fP = false"
.br
.ti -1c
.RI "bool \fBallDownDistanceArrived\fP = false"
.br
.ti -1c
.RI "bool \fBXAligned\fP = false"
.br
.ti -1c
.RI "bool \fBYAligned\fP = false"
.br
.ti -1c
.RI "bool \fBZAligned\fP = false"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line \fB19\fP of file \fBAlignment\&.hpp\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Alignment::Alignment (\fBNema8\fP * Motor_x, \fBNema8\fP * Motor_y, \fBNema8\fP * Motor_z, \fBDistanceSensor\fP * DistanceM_x, \fBDistanceSensor\fP * DistanceM_y, \fBDistanceSensor\fP * DistanceM_z, \fBendSwitch\fP * endSwitch_x, \fBendSwitch\fP * endSwitch_y, \fBendSwitch\fP * endSwitch_z)"

.PP
Definition at line \fB13\fP of file \fBAlignment\&.cpp\fP\&.
.SS "Alignment::Alignment (\fBNema8\fP * Motor_x, \fBNema8\fP * Motor_y, \fBNema8\fP * Motor_z, \fBDistanceSensor\fP * DistanceM_x, \fBDistanceSensor\fP * DistanceM_y, \fBDistanceSensor\fP * DistanceM_z, \fBendSwitch\fP * endSwitch_x, \fBendSwitch\fP * endSwitch_y, \fBendSwitch\fP * endSwitch_z, \fBendSwitch\fP * endSwitch_stop, \fBlightBarrier\fP * lightBarrier_x, \fBlightBarrier\fP * lightBarrier_y, \fBlightBarrier\fP * lightBarrier_z)"

.PP
Definition at line \fB27\fP of file \fBAlignment\&.cpp\fP\&.
.SS "Alignment::Alignment (\fBNema8\fP * Motor_x, \fBNema8\fP * Motor_y, \fBNema8\fP * Motor_z, \fBNema8\fP * Motor_PrintHead, \fBDistanceSensor\fP * DistanceM_x, \fBDistanceSensor\fP * DistanceM_y, \fBDistanceSensor\fP * DistanceM_z, \fBendSwitch\fP * endSwitch_x, \fBendSwitch\fP * endSwitch_y, \fBendSwitch\fP * endSwitch_z, \fBendSwitch\fP * endSwitch_stop, \fBlightBarrier\fP * lightBarrier_x, \fBlightBarrier\fP * lightBarrier_y, \fBlightBarrier\fP * lightBarrier_z)"

.PP
Definition at line \fB44\fP of file \fBAlignment\&.cpp\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBretVal\fP Alignment::AlignLoop ()"

.PP
This is the main function to keep track of alignment during process @algorithm: compare value of distance sensor for each motor with target and calibrate\&. 
.PP
\fBReturns\fP
.RS 4
retVal 
.RE
.PP
TODO_:Better for loop for each Motor
.PP
Definition at line \fB1282\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::calibratePrintHead ()"
calibrate Print Head based on target distance @algorithm: get distance to ML on every Axis (X,Y,Z), move axis in respect to target distance to printhead ( deduced from another fucntion) until target distance is same on all axis 
.PP
\fBReturns\fP
.RS 4
retVal
.RE
.PP

.PP
Definition at line \fB562\fP of file \fBAlignment\&.cpp\fP\&.
.SS "float Alignment::CheckBoundaryX (float targetDistance, int direction)"

.PP
Definition at line \fB1786\fP of file \fBAlignment\&.cpp\fP\&.
.SS "bool Alignment::checkLimitDownX ()\fC [inline]\fP"

.PP
Definition at line \fB384\fP of file \fBAlignment\&.cpp\fP\&.
.SS "bool Alignment::checkLimitDownXYZ ()\fC [inline]\fP"

.PP
Definition at line \fB399\fP of file \fBAlignment\&.cpp\fP\&.
.SS "bool Alignment::checkLimitDownY ()\fC [inline]\fP"

.PP
Definition at line \fB389\fP of file \fBAlignment\&.cpp\fP\&.
.SS "bool Alignment::checkLimitDownZ ()\fC [inline]\fP"

.PP
Definition at line \fB394\fP of file \fBAlignment\&.cpp\fP\&.
.SS "bool Alignment::checkLimitUpX ()\fC [inline]\fP"

.PP
Definition at line \fB363\fP of file \fBAlignment\&.cpp\fP\&.
.SS "bool Alignment::checkLimitUpXYZ ()\fC [inline]\fP"

.PP
Definition at line \fB378\fP of file \fBAlignment\&.cpp\fP\&.
.SS "bool Alignment::checkLimitUpY ()\fC [inline]\fP"

.PP
Definition at line \fB368\fP of file \fBAlignment\&.cpp\fP\&.
.SS "bool Alignment::checkLimitUpZ ()\fC [inline]\fP"

.PP
Definition at line \fB373\fP of file \fBAlignment\&.cpp\fP\&.
.SS "int Alignment::convertAngleToStep (float angle)"

.PP
Definition at line \fB414\fP of file \fBAlignment\&.cpp\fP\&.
.SS "int Alignment::ConvertDistanceToStep (float distance)"

.PP
convert distance in mm or µm to step or microstep 
.PP
\fBParameters\fP
.RS 4
\fIdistance\fP 
.RE
.PP
\fBReturns\fP
.RS 4
int 
.RE
.PP

.PP
Definition at line \fB1817\fP of file \fBAlignment\&.cpp\fP\&.
.SS "int Alignment::convertDistanceToStepMicros (float distance)"

.PP
Definition at line \fB410\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::DisableAll (bool enable = \fC\fBoff\fP\fP)"

.PP
Definition at line \fB1196\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::EnableAll (bool enable = \fC\fBon\fP\fP)"

.PP
Definition at line \fB1189\fP of file \fBAlignment\&.cpp\fP\&.
.SS "float Alignment::getCurrentPosX ()"

.PP
Definition at line \fB1770\fP of file \fBAlignment\&.cpp\fP\&.
.SS "float Alignment::getCurrentPosY ()"

.PP
Definition at line \fB1775\fP of file \fBAlignment\&.cpp\fP\&.
.SS "float Alignment::getCurrentPosZ ()"

.PP
Definition at line \fB1780\fP of file \fBAlignment\&.cpp\fP\&.
.SS "float Alignment::getDistancePlatformToMlX ()\fC [inline]\fP"

.PP
Definition at line \fB457\fP of file \fBAlignment\&.cpp\fP\&.
.SS "float Alignment::getDistancePlatformToMlXYZ ()\fC [inline]\fP"

.PP
Definition at line \fB469\fP of file \fBAlignment\&.cpp\fP\&.
.SS "float Alignment::getDistancePlatformToMlY ()\fC [inline]\fP"

.PP
Definition at line \fB461\fP of file \fBAlignment\&.cpp\fP\&.
.SS "float Alignment::getDistancePlatformToMlZ ()\fC [inline]\fP"

.PP
Definition at line \fB465\fP of file \fBAlignment\&.cpp\fP\&.
.SS "float Alignment::getDistancePrintHeadToMl ()\fC [inline]\fP"

.PP
Definition at line \fB419\fP of file \fBAlignment\&.cpp\fP\&.
.SS "float Alignment::getDistancePrintHeadToMlX ()\fC [inline]\fP"

.PP
Definition at line \fB429\fP of file \fBAlignment\&.cpp\fP\&.
.SS "float Alignment::getDistancePrintHeadToMlY ()\fC [inline]\fP"

.PP
Definition at line \fB438\fP of file \fBAlignment\&.cpp\fP\&.
.SS "float Alignment::getDistancePrintHeadToMlZ ()\fC [inline]\fP"

.PP
Definition at line \fB447\fP of file \fBAlignment\&.cpp\fP\&.
.SS "float Alignment::getMaxX ()"

.PP
Definition at line \fB1750\fP of file \fBAlignment\&.cpp\fP\&.
.SS "float Alignment::getMaxY ()"

.PP
Definition at line \fB1756\fP of file \fBAlignment\&.cpp\fP\&.
.SS "float Alignment::getMaxZ ()"

.PP
Definition at line \fB1762\fP of file \fBAlignment\&.cpp\fP\&.
.SS "float Alignment::getMinX ()"

.PP
get mesured values minus thickness of sensor: equal to 0 position 
.PP
\fBReturns\fP
.RS 4
float 
.RE
.PP

.PP
Definition at line \fB1729\fP of file \fBAlignment\&.cpp\fP\&.
.SS "float Alignment::getMinY ()"

.PP
Definition at line \fB1736\fP of file \fBAlignment\&.cpp\fP\&.
.SS "float Alignment::getMinZ ()"

.PP
Definition at line \fB1743\fP of file \fBAlignment\&.cpp\fP\&.
.SS "bool Alignment::getReadingEndstopX ()\fC [inline]\fP"

.PP
Definition at line \fB336\fP of file \fBAlignment\&.cpp\fP\&.
.SS "bool Alignment::getReadingEndstopY ()\fC [inline]\fP"

.PP
Definition at line \fB340\fP of file \fBAlignment\&.cpp\fP\&.
.SS "bool Alignment::getReadingEndstopZ ()\fC [inline]\fP"

.PP
Definition at line \fB344\fP of file \fBAlignment\&.cpp\fP\&.
.SS "bool Alignment::getReadingLightBarrierX ()\fC [inline]\fP"

.PP
Definition at line \fB349\fP of file \fBAlignment\&.cpp\fP\&.
.SS "bool Alignment::getReadingLightBarrierY ()\fC [inline]\fP"

.PP
Definition at line \fB353\fP of file \fBAlignment\&.cpp\fP\&.
.SS "bool Alignment::getReadingLightBarrierZ ()\fC [inline]\fP"

.PP
Definition at line \fB357\fP of file \fBAlignment\&.cpp\fP\&.
.SS "float Alignment::getRemainingDistanceX ()"

.PP
Definition at line \fB1717\fP of file \fBAlignment\&.cpp\fP\&.
.SS "float Alignment::getRemainingDistanceY ()"

.PP
Definition at line \fB1710\fP of file \fBAlignment\&.cpp\fP\&.
.SS "float Alignment::getRemainingDistanceZ ()"

.PP
get the real distance based on mechanical construction in this setup 
.PP
\fBReturns\fP
.RS 4
float 
.RE
.PP

.PP
Definition at line \fB1702\fP of file \fBAlignment\&.cpp\fP\&.
.SS "double Alignment::getValueSensorX ()\fC [inline]\fP"

.PP
Definition at line \fB323\fP of file \fBAlignment\&.cpp\fP\&.
.SS "double Alignment::getValueSensorY ()\fC [inline]\fP"

.PP
Definition at line \fB327\fP of file \fBAlignment\&.cpp\fP\&.
.SS "double Alignment::getValueSensorZ ()\fC [inline]\fP"

.PP
Definition at line \fB331\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::GoToReferenceDown ()"

.PP
Definition at line \fB406\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::GoToReferenceUp ()"
go to ref up
.PP
Definition at line \fB473\fP of file \fBAlignment\&.cpp\fP\&.
.SS "void Alignment::incrementTotalStepCounted ()"

.PP
Definition at line \fB546\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::InitAlign (bool enable = \fC\fBon\fP\fP)"

.PP
setup stuff to initialise enable, direction and so on 
.PP
\fBReturns\fP
.RS 4
retVal 
.RE
.PP

.PP
Definition at line \fB1182\fP of file \fBAlignment\&.cpp\fP\&.
.SS "void Alignment::initFirmwareUnit ()"

.PP
Definition at line \fB146\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::initSensors ()"

.SS "bool Alignment::isStopButtonPressed ()"

.PP
Definition at line \fB140\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveAngleAll (int direction, float angle)"

.PP
Definition at line \fB314\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveAngleAllSafe (int direction, float Angle)"

.PP
Definition at line \fB883\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveAngleX (int direction, float angle)"

.PP
Definition at line \fB266\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveAngleXSafe (int direction, float Angle)"

.PP
Definition at line \fB808\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveAngleY (int direction, float angle)"

.PP
Definition at line \fB282\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveAngleYSafe (int direction, float Angle)"

.PP
Definition at line \fB833\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveAngleZ (int direction, float angle)"

.PP
Definition at line \fB298\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveAngleZSafe (int direction, float Angle)"

.PP
Definition at line \fB858\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveDistanceAll (int direction, float distance)"

.PP
Definition at line \fB257\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveDistanceAllSafe (int direction, float distance)"

.PP
Definition at line \fB778\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveDistanceMSafe (\fBNema8\fP * Mref, int direction, float distance)"

.PP
Definition at line \fB72\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveDistanceX (int direction, float distance)\fC [inline]\fP"

.PP
Definition at line \fB181\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveDistanceXloop (int direction, float distance)"

.PP
Definition at line \fB79\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveDistanceXSafe (int direction, float distance)"

.PP
Definition at line \fB705\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveDistanceY (int direction, float distance)"

.PP
Definition at line \fB207\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveDistanceYloop (int direction, float distance)"

.PP
Definition at line \fB94\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveDistanceYSafe (int direction, float distance)"

.PP
Definition at line \fB728\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveDistanceZ (int direction, float distance)"

.PP
Definition at line \fB232\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveDistanceZloop (int direction, float distance)"

.PP
Definition at line \fB109\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveDistanceZSafe (int direction, float distance)"

.PP
Definition at line \fB753\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveDown (bool x = \fCtrue\fP, bool y = \fCtrue\fP, bool z = \fCtrue\fP, bool checkLimit = \fCfalse\fP)"

.PP
Definition at line \fB1461\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveDownTo (bool x = \fCtrue\fP, bool y = \fCtrue\fP, bool z = \fCtrue\fP, bool checkLimit = \fCfalse\fP, float distance = \fC0\fP)"

.PP
Definition at line \fB1619\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveHomeAll ()"

.PP
Move all motors home @algorithm: check if every motor endswitch is not pressed, then move \fBNema8\fP up\&. 
.PP
\fBReturns\fP
.RS 4
retVal 
.RE
.PP
: move all motor down to ref
.PP
Definition at line \fB1208\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::movePhToRefX ()"

.PP
Definition at line \fB949\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveUp (bool x = \fCtrue\fP, bool y = \fCtrue\fP, bool z = \fCtrue\fP, bool checkLimit = \fCfalse\fP)"

.PP
Definition at line \fB1384\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::MoveUpTo (bool x = \fCtrue\fP, bool y = \fCtrue\fP, bool z = \fCtrue\fP, bool checkLimit = \fCfalse\fP, float distance = \fC0\fP)"

.PP
Definition at line \fB1542\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::oscillateSys (float desired_angle, int num_revolutions, bool default_sens = \fC\fBclk\fP\fP, bool reverse_sense = \fCtrue\fP)"

.PP
Definition at line \fB971\fP of file \fBAlignment\&.cpp\fP\&.
.SS "void Alignment::resetStepCounter ()"

.PP
Definition at line \fB554\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::rotateAnglePH (int direction, float Angle)"

.PP
Definition at line \fB924\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::RotateAnglePHloop (\fBNema8\fP * Mref, int direction, float angle)"

.PP
Definition at line \fB124\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::rotateFullRevPH (int direction)"

.PP
Definition at line \fB920\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::setTargetDistancePHToML (float distance)"

.PP
set new target distance to ML 
.PP
\fBParameters\fP
.RS 4
\fIdistance\fP 
.RE
.PP
\fBReturns\fP
.RS 4
retVal 
.RE
.PP

.PP
Definition at line \fB1825\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::setTargetDistanceSensorToML (float distance)"

.PP
Definition at line \fB1833\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::StepDownXMax ()"

.PP
Definition at line \fB662\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::StepDownYMax ()"

.PP
Definition at line \fB669\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::StepDownZMax ()"

.PP
Definition at line \fB676\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::StepOncePH (int direction)"

.PP
Definition at line \fB914\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::StepOnceX (int direction)\fC [inline]\fP"

.PP
Definition at line \fB163\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::StepOnceY (int direction)\fC [inline]\fP"

.PP
Definition at line \fB169\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::StepOnceZ (int direction)\fC [inline]\fP"

.PP
Definition at line \fB175\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::StepUpXMax ()"

.PP
Definition at line \fB683\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::StepUpYMax ()"

.PP
Definition at line \fB690\fP of file \fBAlignment\&.cpp\fP\&.
.SS "\fBretVal\fP Alignment::StepUpZMax ()"

.PP
Definition at line \fB697\fP of file \fBAlignment\&.cpp\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "bool Alignment::aligned = false"

.PP
Definition at line \fB45\fP of file \fBAlignment\&.hpp\fP\&.
.SS "bool Alignment::allDownDistanceArrived = false"

.PP
Definition at line \fB61\fP of file \fBAlignment\&.hpp\fP\&.
.SS "bool Alignment::allDownMax = false"

.PP
Definition at line \fB46\fP of file \fBAlignment\&.hpp\fP\&.
.SS "bool Alignment::allUpDistanceArrived = false"

.PP
Definition at line \fB57\fP of file \fBAlignment\&.hpp\fP\&.
.SS "bool Alignment::allUpMax = false"

.PP
Definition at line \fB50\fP of file \fBAlignment\&.hpp\fP\&.
.SS "\fBDistanceSensor\fP* Alignment::DistanceM_x"

.PP
Definition at line \fB32\fP of file \fBAlignment\&.hpp\fP\&.
.SS "\fBDistanceSensor\fP* Alignment::DistanceM_y"

.PP
Definition at line \fB33\fP of file \fBAlignment\&.hpp\fP\&.
.SS "\fBDistanceSensor\fP* Alignment::DistanceM_z"

.PP
Definition at line \fB34\fP of file \fBAlignment\&.hpp\fP\&.
.SS "\fBendSwitch\fP* Alignment::endSwitch_stop"

.PP
Definition at line \fB28\fP of file \fBAlignment\&.hpp\fP\&.
.SS "\fBendSwitch\fP* Alignment::endSwitch_x"

.PP
Definition at line \fB25\fP of file \fBAlignment\&.hpp\fP\&.
.SS "\fBendSwitch\fP* Alignment::endSwitch_y"

.PP
Definition at line \fB26\fP of file \fBAlignment\&.hpp\fP\&.
.SS "\fBendSwitch\fP* Alignment::endSwitch_z"

.PP
Definition at line \fB27\fP of file \fBAlignment\&.hpp\fP\&.
.SS "bool Alignment::homed = false"

.PP
Definition at line \fB44\fP of file \fBAlignment\&.hpp\fP\&.
.SS "\fBlightBarrier\fP* Alignment::lightBarrier_x"

.PP
Definition at line \fB29\fP of file \fBAlignment\&.hpp\fP\&.
.SS "\fBlightBarrier\fP* Alignment::lightBarrier_y"

.PP
Definition at line \fB30\fP of file \fBAlignment\&.hpp\fP\&.
.SS "\fBlightBarrier\fP* Alignment::lightBarrier_z"

.PP
Definition at line \fB31\fP of file \fBAlignment\&.hpp\fP\&.
.SS "const float Alignment::MaxDistanceToMl = 60"

.PP
Definition at line \fB37\fP of file \fBAlignment\&.hpp\fP\&.
.SS "const float Alignment::MinDistanceToML = 10"

.PP
Definition at line \fB36\fP of file \fBAlignment\&.hpp\fP\&.
.SS "\fBNema8\fP* Alignment::Motor_PrintHead"

.PP
Definition at line \fB24\fP of file \fBAlignment\&.hpp\fP\&.
.SS "\fBNema8\fP* Alignment::Motor_x"

.PP
Definition at line \fB21\fP of file \fBAlignment\&.hpp\fP\&.
.SS "\fBNema8\fP* Alignment::Motor_y"

.PP
Definition at line \fB22\fP of file \fBAlignment\&.hpp\fP\&.
.SS "\fBNema8\fP* Alignment::Motor_z"

.PP
Definition at line \fB23\fP of file \fBAlignment\&.hpp\fP\&.
.SS "int Alignment::NumOfCycles =0"

.PP
Definition at line \fB41\fP of file \fBAlignment\&.hpp\fP\&.
.SS "float Alignment::TargetDistancePHToMl =70"

.PP
Definition at line \fB38\fP of file \fBAlignment\&.hpp\fP\&.
.SS "float Alignment::TargetDistanceSensorToMl =165"

.PP
Definition at line \fB39\fP of file \fBAlignment\&.hpp\fP\&.
.SS "bool Alignment::XAligned = false"

.PP
Definition at line \fB63\fP of file \fBAlignment\&.hpp\fP\&.
.SS "bool Alignment::xDownDistanceArrived = false"

.PP
Definition at line \fB58\fP of file \fBAlignment\&.hpp\fP\&.
.SS "bool Alignment::xDownMax = false"

.PP
Definition at line \fB47\fP of file \fBAlignment\&.hpp\fP\&.
.SS "bool Alignment::xUpDistanceArrived = false"

.PP
Definition at line \fB54\fP of file \fBAlignment\&.hpp\fP\&.
.SS "bool Alignment::xUpMax = false"

.PP
Definition at line \fB51\fP of file \fBAlignment\&.hpp\fP\&.
.SS "bool Alignment::YAligned = false"

.PP
Definition at line \fB63\fP of file \fBAlignment\&.hpp\fP\&.
.SS "bool Alignment::yDownDistanceArrived = false"

.PP
Definition at line \fB59\fP of file \fBAlignment\&.hpp\fP\&.
.SS "bool Alignment::yDownMax = false"

.PP
Definition at line \fB48\fP of file \fBAlignment\&.hpp\fP\&.
.SS "bool Alignment::yUpDistanceArrived = false"

.PP
Definition at line \fB55\fP of file \fBAlignment\&.hpp\fP\&.
.SS "bool Alignment::yUpMax = false"

.PP
Definition at line \fB52\fP of file \fBAlignment\&.hpp\fP\&.
.SS "bool Alignment::ZAligned = false"

.PP
Definition at line \fB63\fP of file \fBAlignment\&.hpp\fP\&.
.SS "bool Alignment::zDownDistanceArrived = false"

.PP
Definition at line \fB60\fP of file \fBAlignment\&.hpp\fP\&.
.SS "bool Alignment::zDownMax = false"

.PP
Definition at line \fB49\fP of file \fBAlignment\&.hpp\fP\&.
.SS "bool Alignment::zUpDistanceArrived = false"

.PP
Definition at line \fB56\fP of file \fBAlignment\&.hpp\fP\&.
.SS "bool Alignment::zUpMax = false"

.PP
Definition at line \fB53\fP of file \fBAlignment\&.hpp\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Firmware Design Template from the source code\&.
